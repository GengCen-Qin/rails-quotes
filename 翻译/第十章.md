# Nested Turbo Frames

这一章，我们为line items构建最后的增删改查代码，而line items是嵌入到line items dates中的，为此我们需要使用Turbo Frames去解决一些有趣的挑战。

## What we will build in this chapter

本章中，我们会大致敲定quote编辑器，通过增加line item到line item date中，每一个line items都拥有名称，可选的描述，单价，数量。

这一章的的挑战是我们将会有大量的嵌套Turbo Frames，我们将讨论如何在操作`LineItemDate and LineItem`增删改查时，保证`Quotes#show`页面的状态。

在敲代码前，我们在看一下线上的示例：[final quote editor](https://www.hotrails.dev/quotes)，让我们创建一个quote并且进入对应的`Quotes#show`页面，让每位创建几个 **line item dates and line items**,来对我们最终的产品有一个确定的概念。

当我们清楚了最终产品的样子，我们就开始吧，我们会先不用Turbo Frames and Turbo Streams构建`LineItem`模型的增删改查，在后面Controller都正常运转时，再加入Turbo Rails的特征。

首先，画几个在没有**Turbo Frames and Turbo Streams**时，系统的行为的草图，当我们访问`Quotes#show`页面时，我们展示quote对应的**line item date**，而每个**line item date**都应有多个**line item**,每个**line item date**卡片都有一个"Add item"的链接，去创建专属这条**Line item date**的**line item**

![image-20230628124247522](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230628124247522.png)

在`Quotes#show`页面中，我们应该能为每个quote中的line item date添加line item，当点击"Add item"链接时，应该跳转到`LineItmes#new`页面，这里我们就可以添加该Line item date专属的line item。

假如我们点击第二条line item date的"Add item"链接时，我们期待的页面应该是这样的：

![image-20230628124716265](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230628124716265.png)

当我们正常提交表单时，我们会重定向到`Quotes#show`页面，而新创的数据应该也被添加进去了。

![image-20230628124812981](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230628124812981.png)

如果我们决定更新刚刚创建的line item，我们点击对应的"Edit"链接，到达`LineItems#edit`页面。

![image-20230628125022440](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230628125022440.png)

如果我们提交表单，将再被重定向到`Quotes#show`页面，并且数据被更新

![image-20230628125111148](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230628125111148.png)

最后当想删除这条line item，点击"Delete"，则数据就被删除了。

需求已经理清楚了，开始敲代码吧。

## Creating the model

让我们创建`LineItme`模型，这个模型有五个字段：

- line item date的引用
- 名称
- 可选描述
- 单价
- 数量

```sh
bin/rails generate model LineItem \
  line_item_date:references \
  name:string \
  description:text \
  quantity:integer \
  unit_price:decimal{10-2}
```

执行`rails db:migrate`指令前，我们必须对`name,quantity`添加约束，并且单价肯定非空，通过`null: false`可以在数据库层面进行控制，最终的迁移文件：

```ruby
# db/migrate/XXXXXXXXXXXXXX_create_line_items.rb

class CreateLineItems < ActiveRecord::Migration[7.0]
  def change
    create_table :line_items do |t|
      t.references :line_item_date, null: false, foreign_key: true
      t.string :name, null: false
      t.text :description
      t.integer :quantity, null: false
      t.decimal :unit_price, precision: 10, scale: 2, null: false

      t.timestamps
    end
  end
end
```

现在再执行迁移指令：

```sh
bin/rails db:migrate
```

再到模型中添加对应的关系与校验

```ruby
# app/models/line_item.rb

class LineItem < ApplicationRecord
  belongs_to :line_item_date

  validates :name, presence: true
  validates :quantity, presence: true, numericality: { only_integer: true, greater_than: 0 }
  validates :unit_price, presence: true, numericality: { greater_than: 0 }

  delegate :quote, to: :line_item_date
end
```

这里的校验强制操作：

- 名称，数量，单价不为空
- 单价和数量必须大于0
- 数量必须是数字

我们将委托`quote`方法给`LineItem#line_item_date`方法，这样下面的两个代码是一致的。

```
line_item.line_item_date.quote
line_item.quote
```

现在`LineItem`模型已经好了，再到`LineItemDate`中增加关联关系

```ruby
# app/models/line_item_date.rb

class LineItemDate < ApplicationRecord
  has_many :line_items, dependent: :destroy

  # All the previous code...
end
```

模型层就都可以了，下面开始搞路由部分。

## Adding routes for line items

我们想要执行`LineItem`模型中七个增删改查行为，除了下面两个

- 我们不需要`LineItem#index`，因为所有的line item都会出现在`Quotes#show`页面中。
- 我们也不需要`LineItem#show`，因为查看单个line itme没啥意义。

```ruby
# config/routes.rb

Rails.application.routes.draw do
  # All the previous routes

  resources :quotes do
    resources :line_item_dates, except: [:index, :show] do
      resources :line_items, except: [:index, :show]
    end
  end
end
```

路由就完成了，是时候加一点儿假数据了。

## Designing line items

现在`line item dates`都没有对应的`line items`数据，我们将添加一些假数据到固件(fixtures)中。

让我们想象一下，我们正在构建的quote编辑器是一个企业活动软件。由于事件可以跨越多个日期，我们的quote将有多个日期，而每个日期下都有多个line item！在我们的fixture文件中，我们希望添加一个房间，供客人开会和用餐。让我们在fixture文件中添加这些项目:

```yml
# test/fixtures/line_items.yml

room_today:
  line_item_date: today
  name: Meeting room
  description: A cosy meeting room for 10 people
  quantity: 1
  unit_price: 1000

catering_today:
  line_item_date: today
  name: Meal tray
  description: Our delicious meal tray
  quantity: 10
  unit_price: 25

room_next_week:
  line_item_date: next_week
  name: Meeting room
  description: A cosy meeting room for 10 people
  quantity: 1
  unit_price: 1000

catering_next_week:
  line_item_date: next_week
  name: Meal tray
  description: Our delicious meal tray
  quantity: 10
  unit_price: 25
```

通过`bin/rails db:seed`我们可以插入到数据库中，现在打开项目中"First quote"的`Quotes#show`页面，我们给每个Line item date添加元素在页面中：

- line items集合
- 新建line items的链接

让我们添加到局部模板中：

```ruby
<%# app/views/line_item_dates/_line_item_date.html.erb %>

<%= turbo_frame_tag line_item_date do %>
  <div class="line-item-date">
    <div class="line-item-date__header">
      <!-- All the previous code -->
    </div>
    <div class="line-item-date__body">
      <div class="line-item line-item--header">
        <div class="line-item__name">Article</div>
        <div class="line-item__quantity">Quantity</div>
        <div class="line-item__price">Price</div>
        <div class="line-item__actions"></div>
      </div>

      <%= render line_item_date.line_items, quote: quote, line_item_date: line_item_date %>

      <div class="line-item-date__footer">
        <%= link_to "Add item",
                    [:new, quote, line_item_date, :line_item],
                    class: "btn btn--primary" %>
      </div>
    </div>
  </div>
<% end %>
```

为了渲染每个line item，我们现在创建一个局部模板来展示单条line item

```ruby
<%# app/views/line_items/_line_item.html.erb %>

<div class="line-item">
  <div class="line-item__name">
    <%= line_item.name %>
    <div class="line-item__description">
      <%= simple_format line_item.description %>
    </div>
  </div>
  <div class="line-item__quantity-price">
    <%= line_item.quantity %>
    &times;
    <%= number_to_currency line_item.unit_price %>
  </div>
  <div class="line-item__quantity">
    <%= line_item.quantity %>
  </div>
  <div class="line-item__price">
    <%= number_to_currency line_item.unit_price %>
  </div>
  <div class="line-item__actions">
    <%= button_to "Delete",
                  [quote, line_item_date, line_item],
                  method: :delete,
                  class: "btn btn--light" %>
    <%= link_to "Edit",
                [:edit, quote, line_item_date, line_item],
                class: "btn btn--light" %>
  </div>
</div>
```

`simple_format`helper在渲染那些输入到文本框的文本时很有用。例如，让我们想象一下一个用户输入下面的文本到描述信息汇总。

```
- Appetizer
- Main course
- Dessert
- A glass of wine
```

通过`simple_format`helper将会生成下面的HTML代码

```
<p>
  - Appetizers
  <br>
  - Main course
  <br>
  - Dessert
  <br>
  - A glass of wine
</p>
```

可以看到，这里很只能的加入了换行，如果不使用`simple_format`helper，则信息就只展示到一行中了。

`.line-item__quantity`, `.line-item__price`, and `.line-item__quantity-price` CSS classes可能看起来有点儿多余，但是，只有当屏幕大小高于table And Up断点时，我们才会显示前两个CSS类，而在移动端时展示最后一个CSS类。

现在我们的HTML标签已经好了，让我们加点儿样式，首先，我们完善`.line-item-date`组件，这是我们在上一个章节中使用的`.line-item-date__body` and `.line-item-date__footer`

```css
// app/assets/stylesheets/components/_line_item_date.scss

.line-item-date {
  // All the previous code

  &__body {
    border-radius: var(--border-radius);
    background-color: var(--color-white);
    box-shadow: var(--shadow-small);
    margin-top: var(--space-xs);
    padding: var(--space-xxs);
    padding-top: 0;

    @include media(tabletAndUp) {
      padding: var(--space-m);
    }
  }

  &__footer {
    border: dashed 2px var(--color-light);
    border-radius: var(--border-radius);
    text-align: center;
    padding: var(--space-xxs);

    @include media(tabletAndUp) {
      padding: var(--space-m);
    }
  }
}
```

我们再花点儿时间设计独立的**line item**，这里会写很多CSS：

- `.line-item`基本组件用于单个line item
- `.line-item--header`用于line items集合行上面
- `.line-item--form`用于line item的创建和修改表单

这样不论的是在手机端，平板上，大屏上通过`tabletAndUp`breakpoint都能正常响应，让我们写到代码里

```css
.line-item {
  display: flex;
  align-items: start;
  flex-wrap: wrap;
  background-color: var(--color-white);

  gap: var(--space-xs);
  margin-bottom: var(--space-s);
  padding: var(--space-xs);
  border-radius: var(--border-radius);

  > * {
    margin-bottom: 0;
  }

  &__name {
    flex: 1 1 100%;
    font-weight: bold;

    @include media(tabletAndUp) {
      flex: 1 1 0;
    }
  }

  &__description {
    flex-basis: 100%;
    max-width: 100%;
    color: var(--color-text-muted);
    font-weight: normal;
    font-size: var(--font-size-s);
  }

  &__quantity-price {
    flex: 0 0 auto;
    align-self: flex-end;
    justify-self: flex-end;
    order: 3;

    font-weight: bold;

    @include media(tabletAndUp) {
      display: none;
    }
  }

  &__quantity {
    flex: 1;
    display: none;

    @include media(tabletAndUp) {
      display: revert;
      flex: 0 0 7rem;
    }
  }

  &__price {
    flex: 1;
    display: none;

    @include media(tabletAndUp) {
      display: revert;
      flex: 0 0 9rem;
    }
  }

  &__actions {
    display: flex;
    gap: var(--space-xs);
    order: 2;
    flex: 1 1 auto;

    @include media(tabletAndUp) {
      order: revert;
      flex: 0 0 10rem;
    }
  }

  &--form {
    box-shadow: var(--shadow-small);

    .line-item__quantity,
    .line-item__price {
      display: block;
    }

    .line-item__description {
      order: 2;
    }
  }

  &--header {
    display: none;
    background-color: var(--color-light);
    margin-bottom: var(--space-s);

    @include media(tabletAndUp) {
      display: flex;
    }

    & > * {
      font-size: var(--font-size-s);
      font-weight: bold ;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
  }
}
```

```css
// app/assets/stylesheets/application.sass.scss

// All the previous code
@import "components/line_item";
```

如果你去浏览器中试试，就能看到样式啦

在进入下一部分前，看看我们现在遇到的性能问题，尽管算是本教程的题外话，但在这里解释一下发生了什么也很重要，当我们访问`Quotes#show`页面时，如果你去看rails的日志，你会看到一个 N+1 查看问题

```
...
SELECT "line_items".* FROM "line_items" WHERE "line_items"."line_item_date_id" = $1
...
SELECT "line_items".* FROM "line_items" WHERE "line_items"."line_item_date_id" = $1
...
```

上面的日志中，我们查询`line_items`表两次，因为我们有两条**line item dates**，而如果我们有n条line item dates，那我们就得查询n次了。这是因为我们每次渲染一个新的line item date时，我们都会执行一个请求去获取对应的**line items**,因为这行代码：

```ruby
<%# app/views/line_item_dates/_line_item_date.html.erb %>

<%= render line_item_date.line_items, quote: quote, line_item_date: line_item_date %>
```

**一个很好的性能经验法则是，我们应该在每个请求-响应周期中只查询一次数据库表。**

为了避免N+1查询问题，我们需要提前加载每一个line item date的line items集合，让我们在`QuotesController#show`中修改吧：

```ruby
# app/controllers/quotes_controller.rb

class QuotesController < ApplicationController
  # All the previous code...

  def show
    @line_item_dates = @quote.line_item_dates.includes(:line_items).ordered
  end

  # All the previous code...
end
```

通过加上`includes`，我们会发现日志中，我们只查询了一次数据

```
SELECT "line_items".* FROM "line_items" WHERE "line_items"."line_item_date_id" IN ($1, $2)
```

性能问题已经解决了，是时候去创建`LineItemsController`了。
