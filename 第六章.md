# Turbo Streams and security

本章我们将学习如何安全的使用Turbo Stream 和 避免广播数据到非法的用户。

## Understanding Turbo Streams and security

在将Turbo Streams放在线上环境前，我们必须知道如何保证安全，如果把含有私密数据的HTML发送到了不该接收的人那里，这会是一个很大的问题。

让我们想象一下我们的quote编辑器被一个公司使用，公司内有很多的员工，如果有天我们的数据被一个不属于该公司的人获取到了，那这就是个很大安全事故了。

我们将使用[Devise gem](https://github.com/heartcombo/devise)对用户操作，模拟现实生活来对Turbo Stream security进行学习，并且我们将展示如果我们不够足够重视，将会出现哪些安全问题。

## What we will build

我们将画一个草图来说明本章结束时系统的样子，我们将对没有登录的用户展示登录页面链接

![image-20230608124202557](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230608124202557.png)

然后用户通过输入用户名，密码进行登录

![image-20230608124238125](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230608124238125.png)

我们的用户在登录后跳转到首页，在导航栏中我们将根据电子邮件地址显示公司名称和用户名称，当点击`View quotes`按钮时，他们便可以操作我们的编辑器

![image-20230608124509545](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230608124509545.png)

当点击`View quotes`按钮时，用户将被导航到`Quotes#index`页面，并带有一个导航栏

![image-20230608124718582](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230608124718582.png)

然后我们添加好数据后，我们的系统看起来就可以了，不过我们会在浏览器中找到一个安全问题去做实验。

`Quote,Company,User`的关系如下

- 一个用户属于一个公司
- 一个quote属于一个公司
- 一个公司有多个用户
- 一个公司有多个quote

我们的数据库设计会像下面的草图：

![image-20230608125106104](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230608125106104.png)

我们会使用`rails db:seed`指令去添加数据，来模拟一个真是的场景，在`fixtures`中，我们需要两个公司和三个用户

- **KPMG**公司有两个用户：an **accountant** and a **manager**
- **PwC**公司只有一个用户：一个绝对不该知道**KPMG公司**数据的偷听者。

让我们创建模型，并加入相关的依赖

## Adding companies to our Rails application

创建公司模型

```sh
rails generate model Company name
```

编辑迁移文件，需要保证公司名不能为空，添加：`null:false`进行数据库限制

```ruby
# db/migrate/XXXXXXXXXXXXXX_create_companies.rb

class CreateCompanies < ActiveRecord::Migration[7.0]
  def change
    create_table :companies do |t|
      t.string :name, null: false

      t.timestamps
    end
  end
end
```

执行迁移文件：

```sh
rails db:migrate
```

操作模型，加入非空验证

```ruby
# app/models/company.rb

class Company < ApplicationRecord
  validates :name, presence: true
end
```

在fixture中的companies.yml中加入上面说的数据

```yml
# test/fixtures/companies.yml

kpmg:
  name: KPMG

pwc:
  name: PwC
```

这里我们仅仅需要两个公司去让我们的实验跑通，所以就不用在`CompaniesController`中编完完整的增删改查代码和对应的试图，让我们来添加对应的用户吧。

## Adding users to our application with Devise

我们将使用[Devise gem](https://github.com/heartcombo/devise)来添加用户，并进行权限校验

先添加`Gemfile`

```
# Gemfile

gem "devise", "~> 4.8.1"
```

下载gem

```sh
bundle install
bin/rails generate devise:install
```

使用Devise生成器生成User模型

```sh
bin/rails generate devise User
bin/rails db:migrate
```

现在我们就有了User模型，我们需要页面去串联我们在介绍中描述的样子，但是这里我们不会写注册业务，这里只是为了学习安全相关内容，所以尽量让事情简单一些。

我们仅需要有用户，并能登录，所以我们将关闭Device的所有特性，除了下面两点：

- The feature to sign in users (:database_authenticatable)
- The feature to validate the email and password using Devise built-in validations (:validatable)

下面的我们模型的样子

```ruby
# app/models/user.rb

class User < ApplicationRecord
  devise :database_authenticatable, :validatable
end
```

最后，在创建对应的fixtures文件

```yml
# test/fixtures/users.yml

accountant:
  email: accountant@kpmg.com
  encrypted_password: <%= Devise::Encryptor.digest(User, 'password') %>

manager:
  email: manager@kpmg.com
  encrypted_password: <%= Devise::Encryptor.digest(User, 'password') %>

eavesdropper:
  email: eavesdropper@pwc.com
  encrypted_password: <%= Devise::Encryptor.digest(User, 'password') %>
```

为了安全，Devise存储加密的密码，如果我们希望存储加密后的`password`作为密码，我们需要对应的Devise gem去进行加密，这也是为什么我们使用`Devise::Encryptor.digest`。

现在模型都已经建立好了，接下来我们就对模型建立关联关系。
